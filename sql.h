#pragma once
#include "boost/date_time/posix_time/posix_time.hpp"
#include "coroutine.h"
#include "mysql_driver.h"
#include <atomic>
#include <cppconn/driver.h>
#include <cppconn/exception.h>
#include <cppconn/prepared_statement.h>
#include <cppconn/resultset.h>
#include <cppconn/statement.h>

#include <iostream>
#include <memory>
#include <mutex>
#include <queue>
#include <tuple>

using namespace std;
using namespace boost::gregorian;
using namespace boost::posix_time;

typedef string DBError;
static const DBError nil("");
static const DBError DBClosed("DB Closed");
static const DBError NoFreeConn("Wait Free Conn Timeout");

class DB;
class Statement;
class PreparedStatement;

//* 封装sql::Connection：析构时自动把连接放回连接池；处理异常。
//* 成员函数名和参数 和sql::Connection 成员函数一致,但对返回结果进行了封装
class driverConn : public std::enable_shared_from_this<driverConn> {

public:
    driverConn(std::shared_ptr<sql::Connection>, std::shared_ptr<DB>);
    ~driverConn();
    std::shared_ptr<Statement> createStatement();

    tuple<std::shared_ptr<PreparedStatement>, DBError> prepareStatement(const sql::SQLString& sql);
    tuple<std::shared_ptr<PreparedStatement>, DBError> prepareStatement(const sql::SQLString& sql, int autoGeneratedKeys);
    tuple<std::shared_ptr<PreparedStatement>, DBError> prepareStatement(const sql::SQLString& sql, int* columnIndexes);
    tuple<std::shared_ptr<PreparedStatement>, DBError> prepareStatement(const sql::SQLString& sql, int resultSetType, int resultSetConcurrency);
    tuple<std::shared_ptr<PreparedStatement>, DBError> prepareStatement(const sql::SQLString& sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability);
    tuple<std::shared_ptr<PreparedStatement>, DBError> prepareStatement(const sql::SQLString& sql, sql::SQLString columnNames[]);

    void setAutoCommit(bool autoCommit);
    void rollback();

private:
    std::shared_ptr<sql::Connection> ci; //sql::Connection 连接丢弃时自动delete
    std::shared_ptr<DB> db; //连接池
    int err; //记录该连接上一次执行的错误

public:
    friend class DB;
    friend class Statement;
    friend class PreparedStatement;
};

class Statement {
public:
    Statement(sql::Statement* st, std::shared_ptr<driverConn> c);
    ~Statement();

    tuple<std::shared_ptr<sql::ResultSet>, DBError> executeQuery(const sql::SQLString& sql);
    tuple<int, DBError> executeUpdate(const sql::SQLString& sql);

private:
    sql::Statement* stmt;
    std::shared_ptr<driverConn> dc;
};

class PreparedStatement {
public:
    PreparedStatement(sql::PreparedStatement* st, std::shared_ptr<driverConn> c);
    ~PreparedStatement();

    tuple<std::shared_ptr<sql::ResultSet>, DBError> executeQuery();
    tuple<std::shared_ptr<sql::ResultSet>, DBError> executeQuery(const sql::SQLString& sql);

    tuple<int, DBError> executeUpdate();
    tuple<int, DBError> executeUpdate(const sql::SQLString& sql);

    void setBigInt(unsigned int parameterIndex, const sql::SQLString& value);

    void setBlob(unsigned int parameterIndex, std::istream* blob);

    void setBoolean(unsigned int parameterIndex, bool value);

    void setDateTime(unsigned int parameterIndex, const sql::SQLString& value);

    void setDouble(unsigned int parameterIndex, double value);

    void setInt(unsigned int parameterIndex, int32_t value);

    void setUInt(unsigned int parameterIndex, uint32_t value);

    void setInt64(unsigned int parameterIndex, int64_t value);

    void setUInt64(unsigned int parameterIndex, uint64_t value);

    void setNull(unsigned int parameterIndex, int sqlType);

    void setString(unsigned int parameterIndex, const sql::SQLString& value);

private:
    sql::PreparedStatement* stmt;
    std::shared_ptr<driverConn> dc;
};

struct Requst {
    Requst()
        : addtime(0)
        , ch(2)
    {
        assert(0);
    }
    Requst(uint64_t t)
        : ch(2)
        , addtime(t)
    {
    }
    co_chan<std::shared_ptr<sql::Connection>> ch;
    uint64_t addtime;
};

class DB : public std::enable_shared_from_this<DB> {

public:
    DB();
    ~DB();
    void Open(const sql::ConnectOptionsMap& properties);

    tuple<std::shared_ptr<driverConn>, DBError> GetConn();
    void ReturnConn(std::shared_ptr<sql::Connection> ci, int err);
    void Close();

    tuple<std::shared_ptr<sql::ResultSet>, DBError> executeQuery(const sql::SQLString& sql);
    tuple<int, DBError> executeUpdate(const sql::SQLString& sql);

    friend class driverConn;

private:
    void maybeOpenNewConnLocked();
    void connectionOpener();
    void requestTimer();
    void updateTime();
    tuple<std::shared_ptr<sql::Connection>, DBError> openNewConn();

private:
    sql::mysql::MySQL_Driver* driver;
    sql::ConnectOptionsMap properties;
    bool closed;
    std::atomic<int> numOpen;
    co_mutex mu; // protects following fields
    int maxIdle; // < means unlimited
    int maxOpen; // < means unlimited
    uint64_t reqKey;

    map<uint64_t, Requst> connRequests;
    std::queue<std::shared_ptr<sql::Connection>> freeConn;
    co_chan<bool> openerCh;

    uint64_t millSecond;
    uint64_t second;
    ptime cur;
};
