#include "sql.h"

driverConn::driverConn(std::shared_ptr<sql::Connection> c, std::shared_ptr<DB> d)
    : ci(c)
    , db(d)
    , err(0)
{
}

//* 不用时把连接放回连接池
driverConn::~driverConn()
{
    db->ReturnConn(ci, err);
}
//* 这个应该不会抛出异常
std::shared_ptr<Statement> driverConn::createStatement()
{
    std::shared_ptr<Statement> stmt(new Statement(ci->createStatement(), shared_from_this()));
    return stmt;
}
//* 下面全都会抛出异常 捕捉异常后记录错误码
tuple<std::shared_ptr<PreparedStatement>, DBError> driverConn::prepareStatement(const sql::SQLString& sql)
{
    std::shared_ptr<PreparedStatement> stmt(nullptr);
    DBError dbErr;
    try {
        stmt.reset(new PreparedStatement(ci->prepareStatement(sql), shared_from_this()));
    } catch (sql::SQLException& e) {
        err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        dbErr = ss.str();
    }
    return make_tuple(stmt, dbErr);
}

tuple<std::shared_ptr<PreparedStatement>, DBError> driverConn::prepareStatement(const sql::SQLString& sql, int autoGeneratedKeys)
{
    std::shared_ptr<PreparedStatement> stmt(nullptr);
    DBError dbErr;
    try {
        stmt.reset(new PreparedStatement(ci->prepareStatement(sql, autoGeneratedKeys), shared_from_this()));
    } catch (sql::SQLException& e) {
        err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        dbErr = ss.str();
    }
    return make_tuple(stmt, dbErr);
}
tuple<std::shared_ptr<PreparedStatement>, DBError> driverConn::prepareStatement(const sql::SQLString& sql, int* columnIndexes)
{
    std::shared_ptr<PreparedStatement> stmt(nullptr);
    DBError dbErr;
    try {
        stmt.reset(new PreparedStatement(ci->prepareStatement(sql, columnIndexes), shared_from_this()));
    } catch (sql::SQLException& e) {
        err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        dbErr = ss.str();
    }
    return make_tuple(stmt, dbErr);
}
tuple<std::shared_ptr<PreparedStatement>, DBError> driverConn::prepareStatement(const sql::SQLString& sql, int resultSetType, int resultSetConcurrency)
{
    std::shared_ptr<PreparedStatement> stmt(nullptr);
    DBError dbErr;
    try {
        stmt.reset(new PreparedStatement(ci->prepareStatement(sql, resultSetType, resultSetConcurrency), shared_from_this()));
    } catch (sql::SQLException& e) {
        err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        dbErr = ss.str();
    }
    return make_tuple(stmt, dbErr);
}
tuple<std::shared_ptr<PreparedStatement>, DBError> driverConn::prepareStatement(const sql::SQLString& sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability)
{
    std::shared_ptr<PreparedStatement> stmt(nullptr);
    DBError dbErr;
    try {
        stmt.reset(new PreparedStatement(ci->prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability), shared_from_this()));
    } catch (sql::SQLException& e) {
        err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        dbErr = ss.str();
    }
    return make_tuple(stmt, dbErr);
}
tuple<std::shared_ptr<PreparedStatement>, DBError> driverConn::prepareStatement(const sql::SQLString& sql, sql::SQLString columnNames[])
{
    std::shared_ptr<PreparedStatement> stmt(nullptr);
    DBError dbErr;
    try {
        stmt.reset(new PreparedStatement(ci->prepareStatement(sql, columnNames), shared_from_this()));
    } catch (sql::SQLException& e) {
        err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        dbErr = ss.str();
    }
    return make_tuple(stmt, dbErr);
}

//* autoCommit为false开启事务 应该不会抛出异常?
void driverConn::setAutoCommit(bool autoCommit)
{
    ci->setAutoCommit(autoCommit);
}
//* 回滚不会抛出异常？
void driverConn::rollback()
{
    ci->rollback();
}

Statement::Statement(sql::Statement* st, std::shared_ptr<driverConn> c)
    : stmt(st)
    , dc(c)
{
}

Statement::~Statement()
{
    if (stmt != NULL) {
        delete stmt;
    }
}

tuple<std::shared_ptr<sql::ResultSet>, DBError> Statement::executeQuery(const sql::SQLString& sql)
{
    std::shared_ptr<sql::ResultSet> result(nullptr);
    DBError dbErr;
    try {
        result.reset(stmt->executeQuery(sql));
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        dbErr = ss.str();
    }
    return make_tuple(result, dbErr);
}

tuple<int, DBError> Statement::executeUpdate(const sql::SQLString& sql)
{
    DBError dbErr;
    int affect = 0;
    try {
        affect = stmt->executeUpdate(sql);
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        dbErr = ss.str();
    }
    return make_tuple(affect, dbErr);
}

PreparedStatement::PreparedStatement(sql::PreparedStatement* st, std::shared_ptr<driverConn> c)
    : stmt(st)
    , dc(c)
{
}

PreparedStatement::~PreparedStatement()
{
    if (stmt != NULL) {
        delete stmt;
    }
}

tuple<std::shared_ptr<sql::ResultSet>, DBError> PreparedStatement::executeQuery(const sql::SQLString& sql)
{
    std::shared_ptr<sql::ResultSet> result(nullptr);
    DBError dbErr;
    try {
        result.reset(stmt->executeQuery(sql));
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        dbErr = ss.str();
    }
    return make_tuple(result, dbErr);
}

tuple<std::shared_ptr<sql::ResultSet>, DBError> PreparedStatement::executeQuery()
{
    std::shared_ptr<sql::ResultSet> result(nullptr);
    DBError dbErr;
    try {
        result.reset(stmt->executeQuery());
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        dbErr = ss.str();
    }
    return make_tuple(result, dbErr);
}

tuple<int, DBError> PreparedStatement::executeUpdate(const sql::SQLString& sql)
{
    DBError dbErr;
    int affect = 0;
    try {
        affect = stmt->executeUpdate(sql);
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        dbErr = ss.str();
    }
    return make_tuple(affect, dbErr);
}
tuple<int, DBError> PreparedStatement::executeUpdate()
{
    DBError dbErr;
    int affect = 0;
    try {
        affect = stmt->executeUpdate();
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        dbErr = ss.str();
    }
    return make_tuple(affect, dbErr);
}
//* SetValue 抛出异常 不捕获 是使用问题
void PreparedStatement::setBigInt(unsigned int parameterIndex, const sql::SQLString& value)
{
    try {
        stmt->setBigInt(parameterIndex, value);
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        cout << ss.str() << endl;
    }
}

void PreparedStatement::setBlob(unsigned int parameterIndex, std::istream* blob)
{

    try {
        stmt->setBlob(parameterIndex, blob);
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        cout << ss.str() << endl;
    }
}

void PreparedStatement::setBoolean(unsigned int parameterIndex, bool value)
{
    try {
        stmt->setBoolean(parameterIndex, value);
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        cout << ss.str() << endl;
    }
}

void PreparedStatement::setDateTime(unsigned int parameterIndex, const sql::SQLString& value)
{
    try {
        stmt->setDateTime(parameterIndex, value);
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        cout << ss.str() << endl;
    }
}

void PreparedStatement::setDouble(unsigned int parameterIndex, double value)
{
    try {
        stmt->setDouble(parameterIndex, value);
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        cout << ss.str() << endl;
    }
}

void PreparedStatement::setInt(unsigned int parameterIndex, int32_t value)
{
    try {
        stmt->setInt(parameterIndex, value);
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        cout << ss.str() << endl;
    }
}

void PreparedStatement::setUInt(unsigned int parameterIndex, uint32_t value)
{
    try {
        stmt->setUInt(parameterIndex, value);
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        cout << ss.str() << endl;
    }
}

void PreparedStatement::setInt64(unsigned int parameterIndex, int64_t value)
{
    try {
        stmt->setInt64(parameterIndex, value);
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        cout << ss.str() << endl;
    }
}

void PreparedStatement::setUInt64(unsigned int parameterIndex, uint64_t value)
{
    try {
        stmt->setUInt64(parameterIndex, value);
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        cout << ss.str() << endl;
    }
}

void PreparedStatement::setNull(unsigned int parameterIndex, int sqlType)
{
    try {
        stmt->setNull(parameterIndex, sqlType);
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        cout << ss.str() << endl;
    }
}

void PreparedStatement::setString(unsigned int parameterIndex, const sql::SQLString& value)
{
    try {
        stmt->setString(parameterIndex, value);
    } catch (sql::SQLException& e) {
        dc->err = e.getErrorCode();
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        cout << ss.str() << endl;
    }
}

DB::DB()
    : closed(false)
    , numOpen(0)
    , maxIdle(0)
    , maxOpen(0)
    , reqKey(0)
    , openerCh(1000)
{
}

DB::~DB()
{
    Close();
}

void DB::Open(const sql::ConnectOptionsMap& properties)
{
    driver = sql::mysql::get_mysql_driver_instance();
    this->properties = properties;
    auto it = properties.find("maxOpen");
    if (it != properties.end()) {
        maxOpen = *(it->second).get<int>();
    }
    it = properties.find("maxIdle");
    if (it != properties.end()) {
        maxIdle = *(it->second).get<int>();
    }
    updateTime();
    go[=] { connectionOpener(); };
    go[=] { requestTimer(); };
}

tuple<std::shared_ptr<driverConn>, DBError> DB::GetConn()
{
    bool open = false;
    {
        std::lock_guard<co_mutex> guard(mu);
        if (closed) {
            return make_tuple(nullptr, DBClosed); //errDBClosed
        }
        if (freeConn.size() > 0) {
            auto conn = freeConn.front();
            freeConn.pop();
            std::shared_ptr<driverConn> dc(new driverConn(conn, shared_from_this()));
            return make_tuple(dc, nil);
        }
        //* 可以打开新连接
        if (maxOpen <= 0 || numOpen < maxOpen) {
            ++numOpen;
            //cout << "numopen" << numOpen;
            open = true;
        }
    }
    if (open) {
        auto connResult = openNewConn();
        if (get<1>(connResult) != nil) {
            --numOpen;
            maybeOpenNewConnLocked();
            return make_tuple(nullptr, get<1>(connResult));
        }
        std::shared_ptr<driverConn> dc(new driverConn(get<0>(connResult), shared_from_this()));
        return make_tuple(dc, nil);
    }
    //* 等待空闲连接
    uint64_t reqId;
    Requst req(millSecond);
    {
        std::lock_guard<co_mutex> guard(mu);
        reqId = reqKey++;
        auto res = connRequests.insert(make_pair(reqId, req));
        if (res.second == false) {
            assert(0);
        }
    }

    //cout << "ci yield to get: " << reqId << endl;
    std::shared_ptr<sql::Connection> conn;
    req.ch >> conn;
    if (!conn) {
        //cout << "ci timeout : " << reqId << endl;
        return make_tuple(nullptr, NoFreeConn);
    }
    //cout << "get ci with: " << reqId << endl;
    std::shared_ptr<driverConn> dc(new driverConn(conn, shared_from_this()));
    return make_tuple(dc, nil);
}

void DB::ReturnConn(std::shared_ptr<sql::Connection> ci, int err)
{
    if (err != 0) {
        ci->close();
        --numOpen;
        maybeOpenNewConnLocked();
        cout << "ReturnConn close  err " << numOpen << endl;
        return;
    }
    ////cout << numOpen << endl;

    std::lock_guard<co_mutex> guard(mu);
    if (closed) {
        cout << "ReturnConn dbclose  err " << numOpen << endl;
        return;
    }
    if (maxOpen > 0 && numOpen > maxOpen) {
        cout << "ReturnConn close  maxOpen " << numOpen << endl;
        --numOpen;
        ci->close();
        return;
    }
    if (connRequests.size() > 0) {
        auto it = connRequests.begin();
        auto req = it->second;
        connRequests.erase(it);
        //cout << "begin send ci to: " << it->first << endl;
        req.ch << ci;
        //cout << "end send ci to: " << it->first << endl;
        return;
    }
    if (maxIdle > 0 && freeConn.size() > maxIdle) {
        //cout << "ReturnConn close  maxIdle " << numOpen << endl;
        --numOpen;
        ci->close();
        return;
    }

    freeConn.push(ci);
    return;
}

tuple<std::shared_ptr<sql::ResultSet>, DBError> DB::executeQuery(const sql::SQLString& sql)
{
    if (closed) {
        return make_tuple(nullptr, DBClosed);
    }
    auto connResult = GetConn();
    if (get<1>(connResult) != nil) {
        return make_tuple(nullptr, get<1>(connResult));
    }
    auto stmt = get<0>(connResult)->createStatement();
    return stmt->executeQuery(sql);
}

tuple<int, DBError> DB::executeUpdate(const sql::SQLString& sql)
{
    if (closed) {
        return make_tuple(0, DBClosed);
    }
    auto connResult = GetConn();
    if (get<1>(connResult) != nil) {
        return make_tuple(0, get<1>(connResult));
    }

    auto stmt = get<0>(connResult)->createStatement();
    return stmt->executeUpdate(sql);
}

void DB::Close()
{
    std::lock_guard<co_mutex> guard(mu);
    if (closed) { // Make DB.Close idempotent
        return;
    }
    closed = true;
    //* 关闭连接
    while (freeConn.size() != 0) {
        auto conn = freeConn.front();
        conn->close();
        cout << "conn closed" << endl;
        freeConn.pop();
    }
    openerCh << false;

    return;
}

void DB::maybeOpenNewConnLocked()
{

    std::lock_guard<co_mutex> guard(mu);
    if (closed) {
        return;
    }
    auto numRequests = connRequests.size();
    cout << "numRequests" << numRequests << endl;
    if (maxOpen > 0) {
        auto numCanOpen = maxOpen - numOpen;
        if (numRequests > numCanOpen) {
            numRequests = numCanOpen;
        }
    }
    numOpen += numRequests; //* 直接增加numOpen
    cout << "numRequests" << numRequests << endl;
    while (numRequests > 0) {
        numRequests--;
        openerCh << true;
    }
}

void DB::connectionOpener()
{
    while (1) {
        bool open;
        openerCh >> open;
        if (closed) {
            return;
        }
        // cout << "connectionOpener " << endl;
        auto connResult = openNewConn();
        if (get<1>(connResult) != nil) {
            --numOpen;
            maybeOpenNewConnLocked();
        } else {
            ReturnConn(get<0>(connResult), 0);
        }
    }
}

tuple<std::shared_ptr<sql::Connection>, DBError> DB::openNewConn()
{
    if (closed) {
        return make_tuple(nullptr, DBClosed);
    }
    std::shared_ptr<sql::Connection> conn;
    DBError err;
    try {
        conn.reset(driver->connect(properties));
    } catch (sql::SQLException& e) {
        stringstream ss;
        ss << "ERR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << " )";
        err = ss.str();
    }
    return make_tuple(conn, err);
}
void DB::requestTimer()
{
    while (1) {
        if (closed) {
            return;
        }
        //* sleep 200ms
        co_sleep(200);
        updateTime();
        std::lock_guard<co_mutex> guard(mu);
        while (1) {
            auto it = connRequests.begin();
            if (it == connRequests.end()) {
                break;
            }
            if (it->second.addtime + 2000 < millSecond) {
                cout << "timeout now" << millSecond << " pre " << it->second.addtime << "  reqid " << it->first << endl;
                it->second.ch << nullptr;
                connRequests.erase(it);
            } else {
                break;
            }
        }
    }
}

void DB::updateTime()
{
    cur = microsec_clock::local_time();
    const static ptime begin(date(1970, 1, 1));
    auto duration = cur - begin;
    millSecond = duration.total_milliseconds();
    second = duration.total_seconds();
    //cout << "cur: " << millSecond << endl;
}
